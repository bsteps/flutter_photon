// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'convolution.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
mixin _$Convolution {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ConvolutionCopyWith<$Res> {
  factory $ConvolutionCopyWith(
          Convolution value, $Res Function(Convolution) then) =
      _$ConvolutionCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionCopyWithImpl<$Res> implements $ConvolutionCopyWith<$Res> {
  _$ConvolutionCopyWithImpl(this._value, this._then);

  final Convolution _value;
  // ignore: unused_field
  final $Res Function(Convolution) _then;
}

/// @nodoc
abstract class $ConvolutionBoxBlurCopyWith<$Res> {
  factory $ConvolutionBoxBlurCopyWith(
          ConvolutionBoxBlur value, $Res Function(ConvolutionBoxBlur) then) =
      _$ConvolutionBoxBlurCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionBoxBlurCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionBoxBlurCopyWith<$Res> {
  _$ConvolutionBoxBlurCopyWithImpl(
      ConvolutionBoxBlur _value, $Res Function(ConvolutionBoxBlur) _then)
      : super(_value, (v) => _then(v as ConvolutionBoxBlur));

  @override
  ConvolutionBoxBlur get _value => super._value as ConvolutionBoxBlur;
}

/// @nodoc

class _$ConvolutionBoxBlur extends ConvolutionBoxBlur {
  const _$ConvolutionBoxBlur() : super._();

  @override
  String toString() {
    return 'Convolution.boxBlur()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionBoxBlur);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return boxBlur();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return boxBlur?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (boxBlur != null) {
      return boxBlur();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return boxBlur(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return boxBlur?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (boxBlur != null) {
      return boxBlur(this);
    }
    return orElse();
  }
}

abstract class ConvolutionBoxBlur extends Convolution implements Filter {
  const factory ConvolutionBoxBlur() = _$ConvolutionBoxBlur;
  const ConvolutionBoxBlur._() : super._();
}

/// @nodoc
abstract class $ConvolutionDetect45DegLinesCopyWith<$Res> {
  factory $ConvolutionDetect45DegLinesCopyWith(
          ConvolutionDetect45DegLines value,
          $Res Function(ConvolutionDetect45DegLines) then) =
      _$ConvolutionDetect45DegLinesCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionDetect45DegLinesCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionDetect45DegLinesCopyWith<$Res> {
  _$ConvolutionDetect45DegLinesCopyWithImpl(ConvolutionDetect45DegLines _value,
      $Res Function(ConvolutionDetect45DegLines) _then)
      : super(_value, (v) => _then(v as ConvolutionDetect45DegLines));

  @override
  ConvolutionDetect45DegLines get _value =>
      super._value as ConvolutionDetect45DegLines;
}

/// @nodoc

class _$ConvolutionDetect45DegLines extends ConvolutionDetect45DegLines {
  const _$ConvolutionDetect45DegLines() : super._();

  @override
  String toString() {
    return 'Convolution.detect45DegLines()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionDetect45DegLines);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detect45DegLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return detect45DegLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect45DegLines != null) {
      return detect45DegLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detect45DegLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detect45DegLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect45DegLines != null) {
      return detect45DegLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetect45DegLines extends Convolution
    implements Filter {
  const factory ConvolutionDetect45DegLines() = _$ConvolutionDetect45DegLines;
  const ConvolutionDetect45DegLines._() : super._();
}

/// @nodoc
abstract class $ConvolutionDetect135DegLinesCopyWith<$Res> {
  factory $ConvolutionDetect135DegLinesCopyWith(
          ConvolutionDetect135DegLines value,
          $Res Function(ConvolutionDetect135DegLines) then) =
      _$ConvolutionDetect135DegLinesCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionDetect135DegLinesCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionDetect135DegLinesCopyWith<$Res> {
  _$ConvolutionDetect135DegLinesCopyWithImpl(
      ConvolutionDetect135DegLines _value,
      $Res Function(ConvolutionDetect135DegLines) _then)
      : super(_value, (v) => _then(v as ConvolutionDetect135DegLines));

  @override
  ConvolutionDetect135DegLines get _value =>
      super._value as ConvolutionDetect135DegLines;
}

/// @nodoc

class _$ConvolutionDetect135DegLines extends ConvolutionDetect135DegLines {
  const _$ConvolutionDetect135DegLines() : super._();

  @override
  String toString() {
    return 'Convolution.detect135DegLines()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionDetect135DegLines);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detect135DegLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return detect135DegLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect135DegLines != null) {
      return detect135DegLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detect135DegLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detect135DegLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detect135DegLines != null) {
      return detect135DegLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetect135DegLines extends Convolution
    implements Filter {
  const factory ConvolutionDetect135DegLines() = _$ConvolutionDetect135DegLines;
  const ConvolutionDetect135DegLines._() : super._();
}

/// @nodoc
abstract class $ConvolutionDetectVerticalLinesCopyWith<$Res> {
  factory $ConvolutionDetectVerticalLinesCopyWith(
          ConvolutionDetectVerticalLines value,
          $Res Function(ConvolutionDetectVerticalLines) then) =
      _$ConvolutionDetectVerticalLinesCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionDetectVerticalLinesCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionDetectVerticalLinesCopyWith<$Res> {
  _$ConvolutionDetectVerticalLinesCopyWithImpl(
      ConvolutionDetectVerticalLines _value,
      $Res Function(ConvolutionDetectVerticalLines) _then)
      : super(_value, (v) => _then(v as ConvolutionDetectVerticalLines));

  @override
  ConvolutionDetectVerticalLines get _value =>
      super._value as ConvolutionDetectVerticalLines;
}

/// @nodoc

class _$ConvolutionDetectVerticalLines extends ConvolutionDetectVerticalLines {
  const _$ConvolutionDetectVerticalLines() : super._();

  @override
  String toString() {
    return 'Convolution.detectVerticalLines()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionDetectVerticalLines);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detectVerticalLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return detectVerticalLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectVerticalLines != null) {
      return detectVerticalLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detectVerticalLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detectVerticalLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectVerticalLines != null) {
      return detectVerticalLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetectVerticalLines extends Convolution
    implements Filter {
  const factory ConvolutionDetectVerticalLines() =
      _$ConvolutionDetectVerticalLines;
  const ConvolutionDetectVerticalLines._() : super._();
}

/// @nodoc
abstract class $ConvolutionDetectHorizontalLinesCopyWith<$Res> {
  factory $ConvolutionDetectHorizontalLinesCopyWith(
          ConvolutionDetectHorizontalLines value,
          $Res Function(ConvolutionDetectHorizontalLines) then) =
      _$ConvolutionDetectHorizontalLinesCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionDetectHorizontalLinesCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionDetectHorizontalLinesCopyWith<$Res> {
  _$ConvolutionDetectHorizontalLinesCopyWithImpl(
      ConvolutionDetectHorizontalLines _value,
      $Res Function(ConvolutionDetectHorizontalLines) _then)
      : super(_value, (v) => _then(v as ConvolutionDetectHorizontalLines));

  @override
  ConvolutionDetectHorizontalLines get _value =>
      super._value as ConvolutionDetectHorizontalLines;
}

/// @nodoc

class _$ConvolutionDetectHorizontalLines
    extends ConvolutionDetectHorizontalLines {
  const _$ConvolutionDetectHorizontalLines() : super._();

  @override
  String toString() {
    return 'Convolution.detectHorizontalLines()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionDetectHorizontalLines);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return detectHorizontalLines();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return detectHorizontalLines?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectHorizontalLines != null) {
      return detectHorizontalLines();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return detectHorizontalLines(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return detectHorizontalLines?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (detectHorizontalLines != null) {
      return detectHorizontalLines(this);
    }
    return orElse();
  }
}

abstract class ConvolutionDetectHorizontalLines extends Convolution
    implements Filter {
  const factory ConvolutionDetectHorizontalLines() =
      _$ConvolutionDetectHorizontalLines;
  const ConvolutionDetectHorizontalLines._() : super._();
}

/// @nodoc
abstract class $ConvolutionEdgeDetectionCopyWith<$Res> {
  factory $ConvolutionEdgeDetectionCopyWith(ConvolutionEdgeDetection value,
          $Res Function(ConvolutionEdgeDetection) then) =
      _$ConvolutionEdgeDetectionCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionEdgeDetectionCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionEdgeDetectionCopyWith<$Res> {
  _$ConvolutionEdgeDetectionCopyWithImpl(ConvolutionEdgeDetection _value,
      $Res Function(ConvolutionEdgeDetection) _then)
      : super(_value, (v) => _then(v as ConvolutionEdgeDetection));

  @override
  ConvolutionEdgeDetection get _value =>
      super._value as ConvolutionEdgeDetection;
}

/// @nodoc

class _$ConvolutionEdgeDetection extends ConvolutionEdgeDetection {
  const _$ConvolutionEdgeDetection() : super._();

  @override
  String toString() {
    return 'Convolution.edgeDetection()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionEdgeDetection);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return edgeDetection();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return edgeDetection?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeDetection != null) {
      return edgeDetection();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return edgeDetection(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return edgeDetection?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeDetection != null) {
      return edgeDetection(this);
    }
    return orElse();
  }
}

abstract class ConvolutionEdgeDetection extends Convolution implements Filter {
  const factory ConvolutionEdgeDetection() = _$ConvolutionEdgeDetection;
  const ConvolutionEdgeDetection._() : super._();
}

/// @nodoc
abstract class $ConvolutionEdgeOneCopyWith<$Res> {
  factory $ConvolutionEdgeOneCopyWith(
          ConvolutionEdgeOne value, $Res Function(ConvolutionEdgeOne) then) =
      _$ConvolutionEdgeOneCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionEdgeOneCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionEdgeOneCopyWith<$Res> {
  _$ConvolutionEdgeOneCopyWithImpl(
      ConvolutionEdgeOne _value, $Res Function(ConvolutionEdgeOne) _then)
      : super(_value, (v) => _then(v as ConvolutionEdgeOne));

  @override
  ConvolutionEdgeOne get _value => super._value as ConvolutionEdgeOne;
}

/// @nodoc

class _$ConvolutionEdgeOne extends ConvolutionEdgeOne {
  const _$ConvolutionEdgeOne() : super._();

  @override
  String toString() {
    return 'Convolution.edgeOne()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionEdgeOne);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return edgeOne();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return edgeOne?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeOne != null) {
      return edgeOne();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return edgeOne(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return edgeOne?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (edgeOne != null) {
      return edgeOne(this);
    }
    return orElse();
  }
}

abstract class ConvolutionEdgeOne extends Convolution implements Filter {
  const factory ConvolutionEdgeOne() = _$ConvolutionEdgeOne;
  const ConvolutionEdgeOne._() : super._();
}

/// @nodoc
abstract class $ConvolutionEmbossCopyWith<$Res> {
  factory $ConvolutionEmbossCopyWith(
          ConvolutionEmboss value, $Res Function(ConvolutionEmboss) then) =
      _$ConvolutionEmbossCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionEmbossCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionEmbossCopyWith<$Res> {
  _$ConvolutionEmbossCopyWithImpl(
      ConvolutionEmboss _value, $Res Function(ConvolutionEmboss) _then)
      : super(_value, (v) => _then(v as ConvolutionEmboss));

  @override
  ConvolutionEmboss get _value => super._value as ConvolutionEmboss;
}

/// @nodoc

class _$ConvolutionEmboss extends ConvolutionEmboss {
  const _$ConvolutionEmboss() : super._();

  @override
  String toString() {
    return 'Convolution.emboss()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionEmboss);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return emboss();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return emboss?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (emboss != null) {
      return emboss();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return emboss(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return emboss?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (emboss != null) {
      return emboss(this);
    }
    return orElse();
  }
}

abstract class ConvolutionEmboss extends Convolution implements Filter {
  const factory ConvolutionEmboss() = _$ConvolutionEmboss;
  const ConvolutionEmboss._() : super._();
}

/// @nodoc
abstract class $ConvolutionIdentityCopyWith<$Res> {
  factory $ConvolutionIdentityCopyWith(
          ConvolutionIdentity value, $Res Function(ConvolutionIdentity) then) =
      _$ConvolutionIdentityCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionIdentityCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionIdentityCopyWith<$Res> {
  _$ConvolutionIdentityCopyWithImpl(
      ConvolutionIdentity _value, $Res Function(ConvolutionIdentity) _then)
      : super(_value, (v) => _then(v as ConvolutionIdentity));

  @override
  ConvolutionIdentity get _value => super._value as ConvolutionIdentity;
}

/// @nodoc

class _$ConvolutionIdentity extends ConvolutionIdentity {
  const _$ConvolutionIdentity() : super._();

  @override
  String toString() {
    return 'Convolution.identity()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionIdentity);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return identity();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return identity?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (identity != null) {
      return identity();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return identity(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return identity?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (identity != null) {
      return identity(this);
    }
    return orElse();
  }
}

abstract class ConvolutionIdentity extends Convolution implements Filter {
  const factory ConvolutionIdentity() = _$ConvolutionIdentity;
  const ConvolutionIdentity._() : super._();
}

/// @nodoc
abstract class $ConvolutionLaplaceCopyWith<$Res> {
  factory $ConvolutionLaplaceCopyWith(
          ConvolutionLaplace value, $Res Function(ConvolutionLaplace) then) =
      _$ConvolutionLaplaceCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionLaplaceCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionLaplaceCopyWith<$Res> {
  _$ConvolutionLaplaceCopyWithImpl(
      ConvolutionLaplace _value, $Res Function(ConvolutionLaplace) _then)
      : super(_value, (v) => _then(v as ConvolutionLaplace));

  @override
  ConvolutionLaplace get _value => super._value as ConvolutionLaplace;
}

/// @nodoc

class _$ConvolutionLaplace extends ConvolutionLaplace {
  const _$ConvolutionLaplace() : super._();

  @override
  String toString() {
    return 'Convolution.laplace()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionLaplace);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return laplace();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return laplace?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (laplace != null) {
      return laplace();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return laplace(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return laplace?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (laplace != null) {
      return laplace(this);
    }
    return orElse();
  }
}

abstract class ConvolutionLaplace extends Convolution implements Filter {
  const factory ConvolutionLaplace() = _$ConvolutionLaplace;
  const ConvolutionLaplace._() : super._();
}

/// @nodoc
abstract class $ConvolutionNoiseReductionCopyWith<$Res> {
  factory $ConvolutionNoiseReductionCopyWith(ConvolutionNoiseReduction value,
          $Res Function(ConvolutionNoiseReduction) then) =
      _$ConvolutionNoiseReductionCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionNoiseReductionCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionNoiseReductionCopyWith<$Res> {
  _$ConvolutionNoiseReductionCopyWithImpl(ConvolutionNoiseReduction _value,
      $Res Function(ConvolutionNoiseReduction) _then)
      : super(_value, (v) => _then(v as ConvolutionNoiseReduction));

  @override
  ConvolutionNoiseReduction get _value =>
      super._value as ConvolutionNoiseReduction;
}

/// @nodoc

class _$ConvolutionNoiseReduction extends ConvolutionNoiseReduction {
  const _$ConvolutionNoiseReduction() : super._();

  @override
  String toString() {
    return 'Convolution.noiseReduction()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionNoiseReduction);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return noiseReduction();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return noiseReduction?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (noiseReduction != null) {
      return noiseReduction();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return noiseReduction(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return noiseReduction?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (noiseReduction != null) {
      return noiseReduction(this);
    }
    return orElse();
  }
}

abstract class ConvolutionNoiseReduction extends Convolution implements Filter {
  const factory ConvolutionNoiseReduction() = _$ConvolutionNoiseReduction;
  const ConvolutionNoiseReduction._() : super._();
}

/// @nodoc
abstract class $ConvolutionPrewittHorizontalCopyWith<$Res> {
  factory $ConvolutionPrewittHorizontalCopyWith(
          ConvolutionPrewittHorizontal value,
          $Res Function(ConvolutionPrewittHorizontal) then) =
      _$ConvolutionPrewittHorizontalCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionPrewittHorizontalCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionPrewittHorizontalCopyWith<$Res> {
  _$ConvolutionPrewittHorizontalCopyWithImpl(
      ConvolutionPrewittHorizontal _value,
      $Res Function(ConvolutionPrewittHorizontal) _then)
      : super(_value, (v) => _then(v as ConvolutionPrewittHorizontal));

  @override
  ConvolutionPrewittHorizontal get _value =>
      super._value as ConvolutionPrewittHorizontal;
}

/// @nodoc

class _$ConvolutionPrewittHorizontal extends ConvolutionPrewittHorizontal {
  const _$ConvolutionPrewittHorizontal() : super._();

  @override
  String toString() {
    return 'Convolution.prewittHorizontal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionPrewittHorizontal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return prewittHorizontal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return prewittHorizontal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (prewittHorizontal != null) {
      return prewittHorizontal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return prewittHorizontal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return prewittHorizontal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (prewittHorizontal != null) {
      return prewittHorizontal(this);
    }
    return orElse();
  }
}

abstract class ConvolutionPrewittHorizontal extends Convolution
    implements Filter {
  const factory ConvolutionPrewittHorizontal() = _$ConvolutionPrewittHorizontal;
  const ConvolutionPrewittHorizontal._() : super._();
}

/// @nodoc
abstract class $ConvolutionSharpenCopyWith<$Res> {
  factory $ConvolutionSharpenCopyWith(
          ConvolutionSharpen value, $Res Function(ConvolutionSharpen) then) =
      _$ConvolutionSharpenCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionSharpenCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionSharpenCopyWith<$Res> {
  _$ConvolutionSharpenCopyWithImpl(
      ConvolutionSharpen _value, $Res Function(ConvolutionSharpen) _then)
      : super(_value, (v) => _then(v as ConvolutionSharpen));

  @override
  ConvolutionSharpen get _value => super._value as ConvolutionSharpen;
}

/// @nodoc

class _$ConvolutionSharpen extends ConvolutionSharpen {
  const _$ConvolutionSharpen() : super._();

  @override
  String toString() {
    return 'Convolution.sharpen()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionSharpen);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return sharpen();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return sharpen?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sharpen != null) {
      return sharpen();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return sharpen(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return sharpen?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sharpen != null) {
      return sharpen(this);
    }
    return orElse();
  }
}

abstract class ConvolutionSharpen extends Convolution implements Filter {
  const factory ConvolutionSharpen() = _$ConvolutionSharpen;
  const ConvolutionSharpen._() : super._();
}

/// @nodoc
abstract class $ConvolutionSobelHorizontalCopyWith<$Res> {
  factory $ConvolutionSobelHorizontalCopyWith(ConvolutionSobelHorizontal value,
          $Res Function(ConvolutionSobelHorizontal) then) =
      _$ConvolutionSobelHorizontalCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionSobelHorizontalCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionSobelHorizontalCopyWith<$Res> {
  _$ConvolutionSobelHorizontalCopyWithImpl(ConvolutionSobelHorizontal _value,
      $Res Function(ConvolutionSobelHorizontal) _then)
      : super(_value, (v) => _then(v as ConvolutionSobelHorizontal));

  @override
  ConvolutionSobelHorizontal get _value =>
      super._value as ConvolutionSobelHorizontal;
}

/// @nodoc

class _$ConvolutionSobelHorizontal extends ConvolutionSobelHorizontal {
  const _$ConvolutionSobelHorizontal() : super._();

  @override
  String toString() {
    return 'Convolution.sobelHorizontal()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionSobelHorizontal);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return sobelHorizontal();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return sobelHorizontal?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelHorizontal != null) {
      return sobelHorizontal();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return sobelHorizontal(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return sobelHorizontal?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelHorizontal != null) {
      return sobelHorizontal(this);
    }
    return orElse();
  }
}

abstract class ConvolutionSobelHorizontal extends Convolution
    implements Filter {
  const factory ConvolutionSobelHorizontal() = _$ConvolutionSobelHorizontal;
  const ConvolutionSobelHorizontal._() : super._();
}

/// @nodoc
abstract class $ConvolutionSobelVerticalCopyWith<$Res> {
  factory $ConvolutionSobelVerticalCopyWith(ConvolutionSobelVertical value,
          $Res Function(ConvolutionSobelVertical) then) =
      _$ConvolutionSobelVerticalCopyWithImpl<$Res>;
}

/// @nodoc
class _$ConvolutionSobelVerticalCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionSobelVerticalCopyWith<$Res> {
  _$ConvolutionSobelVerticalCopyWithImpl(ConvolutionSobelVertical _value,
      $Res Function(ConvolutionSobelVertical) _then)
      : super(_value, (v) => _then(v as ConvolutionSobelVertical));

  @override
  ConvolutionSobelVertical get _value =>
      super._value as ConvolutionSobelVertical;
}

/// @nodoc

class _$ConvolutionSobelVertical extends ConvolutionSobelVertical {
  const _$ConvolutionSobelVertical() : super._();

  @override
  String toString() {
    return 'Convolution.sobelVertical()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is ConvolutionSobelVertical);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return sobelVertical();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return sobelVertical?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelVertical != null) {
      return sobelVertical();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return sobelVertical(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return sobelVertical?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (sobelVertical != null) {
      return sobelVertical(this);
    }
    return orElse();
  }
}

abstract class ConvolutionSobelVertical extends Convolution implements Filter {
  const factory ConvolutionSobelVertical() = _$ConvolutionSobelVertical;
  const ConvolutionSobelVertical._() : super._();
}

/// @nodoc
abstract class $ConvolutionGaussianBlurCopyWith<$Res> {
  factory $ConvolutionGaussianBlurCopyWith(ConvolutionGaussianBlur value,
          $Res Function(ConvolutionGaussianBlur) then) =
      _$ConvolutionGaussianBlurCopyWithImpl<$Res>;
  $Res call({int radius});
}

/// @nodoc
class _$ConvolutionGaussianBlurCopyWithImpl<$Res>
    extends _$ConvolutionCopyWithImpl<$Res>
    implements $ConvolutionGaussianBlurCopyWith<$Res> {
  _$ConvolutionGaussianBlurCopyWithImpl(ConvolutionGaussianBlur _value,
      $Res Function(ConvolutionGaussianBlur) _then)
      : super(_value, (v) => _then(v as ConvolutionGaussianBlur));

  @override
  ConvolutionGaussianBlur get _value => super._value as ConvolutionGaussianBlur;

  @override
  $Res call({
    Object? radius = freezed,
  }) {
    return _then(ConvolutionGaussianBlur(
      radius: radius == freezed
          ? _value.radius
          : radius // ignore: cast_nullable_to_non_nullable
              as int,
    ));
  }
}

/// @nodoc

class _$ConvolutionGaussianBlur extends ConvolutionGaussianBlur {
  const _$ConvolutionGaussianBlur({required this.radius}) : super._();

  @override
  final int radius;

  @override
  String toString() {
    return 'Convolution.gaussianBlur(radius: $radius)';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is ConvolutionGaussianBlur &&
            const DeepCollectionEquality().equals(other.radius, radius));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, const DeepCollectionEquality().hash(radius));

  @JsonKey(ignore: true)
  @override
  $ConvolutionGaussianBlurCopyWith<ConvolutionGaussianBlur> get copyWith =>
      _$ConvolutionGaussianBlurCopyWithImpl<ConvolutionGaussianBlur>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() boxBlur,
    required TResult Function() detect45DegLines,
    required TResult Function() detect135DegLines,
    required TResult Function() detectVerticalLines,
    required TResult Function() detectHorizontalLines,
    required TResult Function() edgeDetection,
    required TResult Function() edgeOne,
    required TResult Function() emboss,
    required TResult Function() identity,
    required TResult Function() laplace,
    required TResult Function() noiseReduction,
    required TResult Function() prewittHorizontal,
    required TResult Function() sharpen,
    required TResult Function() sobelHorizontal,
    required TResult Function() sobelVertical,
    required TResult Function(int radius) gaussianBlur,
  }) {
    return gaussianBlur(radius);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
  }) {
    return gaussianBlur?.call(radius);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? boxBlur,
    TResult Function()? detect45DegLines,
    TResult Function()? detect135DegLines,
    TResult Function()? detectVerticalLines,
    TResult Function()? detectHorizontalLines,
    TResult Function()? edgeDetection,
    TResult Function()? edgeOne,
    TResult Function()? emboss,
    TResult Function()? identity,
    TResult Function()? laplace,
    TResult Function()? noiseReduction,
    TResult Function()? prewittHorizontal,
    TResult Function()? sharpen,
    TResult Function()? sobelHorizontal,
    TResult Function()? sobelVertical,
    TResult Function(int radius)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (gaussianBlur != null) {
      return gaussianBlur(radius);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(ConvolutionBoxBlur value) boxBlur,
    required TResult Function(ConvolutionDetect45DegLines value)
        detect45DegLines,
    required TResult Function(ConvolutionDetect135DegLines value)
        detect135DegLines,
    required TResult Function(ConvolutionDetectVerticalLines value)
        detectVerticalLines,
    required TResult Function(ConvolutionDetectHorizontalLines value)
        detectHorizontalLines,
    required TResult Function(ConvolutionEdgeDetection value) edgeDetection,
    required TResult Function(ConvolutionEdgeOne value) edgeOne,
    required TResult Function(ConvolutionEmboss value) emboss,
    required TResult Function(ConvolutionIdentity value) identity,
    required TResult Function(ConvolutionLaplace value) laplace,
    required TResult Function(ConvolutionNoiseReduction value) noiseReduction,
    required TResult Function(ConvolutionPrewittHorizontal value)
        prewittHorizontal,
    required TResult Function(ConvolutionSharpen value) sharpen,
    required TResult Function(ConvolutionSobelHorizontal value) sobelHorizontal,
    required TResult Function(ConvolutionSobelVertical value) sobelVertical,
    required TResult Function(ConvolutionGaussianBlur value) gaussianBlur,
  }) {
    return gaussianBlur(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
  }) {
    return gaussianBlur?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(ConvolutionBoxBlur value)? boxBlur,
    TResult Function(ConvolutionDetect45DegLines value)? detect45DegLines,
    TResult Function(ConvolutionDetect135DegLines value)? detect135DegLines,
    TResult Function(ConvolutionDetectVerticalLines value)? detectVerticalLines,
    TResult Function(ConvolutionDetectHorizontalLines value)?
        detectHorizontalLines,
    TResult Function(ConvolutionEdgeDetection value)? edgeDetection,
    TResult Function(ConvolutionEdgeOne value)? edgeOne,
    TResult Function(ConvolutionEmboss value)? emboss,
    TResult Function(ConvolutionIdentity value)? identity,
    TResult Function(ConvolutionLaplace value)? laplace,
    TResult Function(ConvolutionNoiseReduction value)? noiseReduction,
    TResult Function(ConvolutionPrewittHorizontal value)? prewittHorizontal,
    TResult Function(ConvolutionSharpen value)? sharpen,
    TResult Function(ConvolutionSobelHorizontal value)? sobelHorizontal,
    TResult Function(ConvolutionSobelVertical value)? sobelVertical,
    TResult Function(ConvolutionGaussianBlur value)? gaussianBlur,
    required TResult orElse(),
  }) {
    if (gaussianBlur != null) {
      return gaussianBlur(this);
    }
    return orElse();
  }
}

abstract class ConvolutionGaussianBlur extends Convolution implements Filter {
  const factory ConvolutionGaussianBlur({required final int radius}) =
      _$ConvolutionGaussianBlur;
  const ConvolutionGaussianBlur._() : super._();

  int get radius => throw _privateConstructorUsedError;
  @JsonKey(ignore: true)
  $ConvolutionGaussianBlurCopyWith<ConvolutionGaussianBlur> get copyWith =>
      throw _privateConstructorUsedError;
}
